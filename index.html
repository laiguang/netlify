<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>专注水平仪</title>
    <!-- 引入圆润可爱的字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #E0F7FA; /* 冰雪蓝背景 */
            --glass-white: rgba(255, 255, 255, 0.85);
            --ac-blue: #2BBBAD;
            --ac-text: #546E7A;
            --neon-red: #FF1744;
            --neon-green: #00E676;
            --shadow-red: 0 0 15px var(--neon-red), inset 0 0 10px var(--neon-red);
            --shadow-green: 0 0 15px var(--neon-green), inset 0 0 10px var(--neon-green);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(255, 255, 255, 0.4) 10%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(255, 255, 255, 0.4) 10%, transparent 20%);
            font-family: 'Nunito', sans-serif;
            color: var(--ac-text);
            overflow: hidden;
            position: relative;
        }

        /* 雪花画布层 */
        #snow-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* 顶部角度显示 */
        .angle-display {
            margin-top: 10vh;
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 2px 2px 0px white;
            z-index: 20;
        }

        /* 中间水平仪区域 */
        .level-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            z-index: 20;
        }

        .level-outer {
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 4px solid white;
            box-shadow: 0 10px 20px rgba(0,0,0,0.05);
            position: relative;
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 中心准星 */
        .level-center-mark {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px dashed rgba(255,255,255,0.6);
            position: absolute;
        }

        .level-bubble {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            position: absolute;
            transition: transform 0.1s linear, box-shadow 0.3s ease, background 0.3s ease;
            transform: translate(0, 0);
            /* 默认红色状态 */
            background: rgba(255, 23, 68, 0.1);
            border: 2px solid var(--neon-red);
            box-shadow: var(--shadow-red);
        }

        .level-bubble.level-ok {
            background: rgba(0, 230, 118, 0.1);
            border: 2px solid var(--neon-green);
            box-shadow: var(--shadow-green);
        }

        /* 下方计时区 */
        .timer-display {
            font-size: 3rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            margin-bottom: 20px;
            background: var(--glass-white);
            padding: 10px 30px;
            border-radius: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            z-index: 20;
        }

        /* 按钮区 */
        .controls {
            height: 15vh;
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            z-index: 20;
            width: 100%;
            margin-bottom: 20px;
        }

        .btn {
            width: 70px;
            height: 70px;
            border-radius: 20px;
            background: white;
            border: none;
            box-shadow: 0 8px 0 #E0E0E0;
            font-size: 1.5rem;
            color: var(--ac-text);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 4px 0 #E0E0E0;
        }

        .btn-count {
            font-size: 2rem;
            font-weight: bold;
            color: var(--ac-blue);
        }

        .hidden {
            display: none !important;
        }

        /* PC交互提示覆盖层 */
        #pc-instruction {
            display: none;
        }

        @media (min-width: 768px) {
            .level-outer {
                width: 350px;
                height: 350px;
            }
        }
    </style>
</head>
<body>

    <!-- 雪花层 -->
    <canvas id="snow-canvas"></canvas>

    <!-- 顶部角度 -->
    <div class="angle-display" id="angleText">0°</div>

    <!-- 中间水平仪 -->
    <div class="level-container">
        <div class="level-outer" id="levelOuter">
            <div class="level-center-mark"></div>
            <div class="level-bubble" id="bubble"></div>
        </div>
    </div>

    <!-- 下方计时器 -->
    <div class="timer-display" id="timer">00 : 00 : 00</div>

    <!-- 按钮区 -->
    <div class="controls">
        <!-- 初始播放/倒计时按钮 -->
        <button class="btn" id="btnPlay">
            <svg width="30" height="30" viewBox="0 0 24 24" fill="currentColor">
                <path d="M8 5v14l11-7z"/>
            </svg>
        </button>
        
        <!-- 暂停后的双按钮组 -->
        <button class="btn hidden" id="btnResume">
            <svg width="30" height="30" viewBox="0 0 24 24" fill="currentColor">
                <path d="M8 5v14l11-7z"/>
            </svg>
        </button>
        <button class="btn hidden" id="btnRestart">
            <svg width="30" height="30" viewBox="0 0 24 24" fill="currentColor">
                <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
            </svg>
        </button>
    </div>

    <script>
        // --- 核心状态 ---
        const state = {
            angle: 0,
            isLevel: true, // 是否水平
            status: 'idle', // idle, counting_down, running, paused
            startTime: 0,
            elapsedTime: 0, // ms
            timerInterval: null,
            bubbleX: 0,
            bubbleY: 0
        };

        // --- DOM 元素 ---
        const ui = {
            angle: document.getElementById('angleText'),
            outer: document.getElementById('levelOuter'),
            bubble: document.getElementById('bubble'),
            timer: document.getElementById('timer'),
            btnPlay: document.getElementById('btnPlay'),
            btnResume: document.getElementById('btnResume'),
            btnRestart: document.getElementById('btnRestart'),
            snowCanvas: document.getElementById('snow-canvas')
        };

        // --- 水平仪逻辑 (核心) ---
        const MAX_TILT = 30; // 最大显示倾斜度
        const RADIUS = ui.outer.offsetWidth / 2 - 20; // 气泡活动半径
        
        function updateBubble(xTilt, yTilt) {
            // 计算总倾斜角度 (勾股定理)
            let tiltMagnitude = Math.sqrt(xTilt*xTilt + yTilt*yTilt);
            state.angle = Math.round(tiltMagnitude);
            ui.angle.innerText = state.angle + '°';

            // 限制气泡在圆内
            const distance = Math.min(tiltMagnitude * 5, RADIUS); // 敏感度系数
            const angleRad = Math.atan2(yTilt, xTilt);
            
            const px = Math.cos(angleRad) * distance;
            const py = Math.sin(angleRad) * distance;

            ui.bubble.style.transform = `translate(${px}px, ${py}px)`;

            // 判断是否水平 (误差±3°)
            // 注意：这里我们用 tiltMagnitude 作为总倾斜度判断
            const isNowLevel = tiltMagnitude <= 3;
            
            if (isNowLevel !== state.isLevel) {
                state.isLevel = isNowLevel;
                if (isNowLevel) {
                    ui.bubble.classList.add('level-ok');
                } else {
                    ui.bubble.classList.remove('level-ok');
                }
            }

            // 如果正在计时，且水平状态被打破
            if (state.status === 'running' && !isNowLevel) {
                pauseTimer("balance_lost");
            }
        }

        // --- 输入事件监听 ---

        // 1. 移动端陀螺仪
        window.addEventListener('deviceorientation', (event) => {
            // beta: x轴倾斜 (-180, 180), gamma: y轴倾斜 (-90, 90)
            let x = event.gamma || 0; // 左右倾斜
            let y = event.beta || 0;  // 前后倾斜
            
            // 修正：一般手机平放时 beta 为 0, gamma 为 0
            // 限制一下最大值，防止气泡飞太远逻辑混乱
            if (x > 90) x = 90; if (x < -90) x = -90;
            if (y > 90) y = 90; if (y < -90) y = -90;

            updateBubble(x, y);
        });

        // 2. 电脑端鼠标模拟
        window.addEventListener('mousemove', (e) => {
            const rect = ui.outer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            // 计算鼠标相对于圆心的位置
            let dx = e.clientX - centerX;
            let dy = e.clientY - centerY;

            // 映射距离到角度 (模拟: 距离圆心100px = 10度)
            const factor = 0.1; 
            updateBubble(dx * factor, dy * factor);
        });


        // --- 计时器逻辑 ---

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = totalSeconds % 60;
            return `${String(h).padStart(2, '0')} : ${String(m).padStart(2, '0')} : ${String(s).padStart(2, '0')}`;
        }

        function startCountdown(onComplete) {
            state.status = 'counting_down';
            let count = 5;
            
            // 隐藏其他按钮，显示倒计时在主按钮上
            ui.btnPlay.classList.remove('hidden');
            ui.btnResume.classList.add('hidden');
            ui.btnRestart.classList.add('hidden');
            
            // 禁用点击
            ui.btnPlay.disabled = true;
            ui.btnPlay.innerHTML = `<span class="btn-count">${count}</span>`;

            const intv = setInterval(() => {
                count--;
                if (count > 0) {
                    ui.btnPlay.innerHTML = `<span class="btn-count">${count}</span>`;
                } else {
                    clearInterval(intv);
                    ui.btnPlay.disabled = false;
                    onComplete();
                }
            }, 1000);
        }

        function startTimer() {
            // 检查水平
            if (!state.isLevel) {
                alert("请保持设备水平");
                resetToIdle();
                return;
            }

            state.status = 'running';
            // UI 变更
            ui.btnPlay.classList.add('hidden'); // 隐藏原播放按钮
            ui.btnResume.classList.add('hidden');
            ui.btnRestart.classList.add('hidden');
            
            // 显示暂停图标 (虽然此时没有按钮显示，根据需求2: 
            // "显示暂停图标...开始计时"。这里有点歧义，如果按钮区没按钮，暂停图标显示在哪？
            // 结合需求3 "暂停按钮被点击"，说明此时应该显示一个暂停按钮)
            // 既然播放按钮消失了，我们复用 play 按钮的位置显示 Pause，或者直接显示“工作中...”
            // 根据需求3，需要能点击暂停。所以我们把 btnPlay 变成暂停样式。
            
            ui.btnPlay.classList.remove('hidden');
            ui.btnPlay.innerHTML = `
                <svg width="30" height="30" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                </svg>
            `;

            // 启动计时
            const startTimestamp = Date.now() - state.elapsedTime;
            state.timerInterval = setInterval(() => {
                state.elapsedTime = Date.now() - startTimestamp;
                ui.timer.innerText = formatTime(state.elapsedTime);
            }, 1000);

            // 启动雪花生成
            snowSystem.isGenerating = true;
            snowSystem.isFrozen = false;
        }

        function pauseTimer(reason) {
            state.status = 'paused';
            clearInterval(state.timerInterval);
            
            // 雪花静止
            snowSystem.isFrozen = true;
            snowSystem.isGenerating = false;

            // UI 变更
            ui.btnPlay.classList.add('hidden'); // 隐藏暂停(原Play)按钮
            ui.btnResume.classList.remove('hidden'); // 显示继续
            ui.btnRestart.classList.remove('hidden'); // 显示重开

            if (reason === "balance_lost") {
                // 需求不显示文字，但通常这里用户会困惑为什么停了，不过按照需求"不出现提示性文字"
            }
        }

        function resetToIdle() {
            state.status = 'idle';
            clearInterval(state.timerInterval);
            state.elapsedTime = 0;
            ui.timer.innerText = "00 : 00 : 00";

            // 按钮重置
            ui.btnPlay.classList.remove('hidden');
            ui.btnPlay.disabled = false;
            ui.btnPlay.innerHTML = `
                <svg width="30" height="30" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M8 5v14l11-7z"/>
                </svg>
            `;
            ui.btnResume.classList.add('hidden');
            ui.btnRestart.classList.add('hidden');

            // 雪花逻辑：停止生成，现有雪花飘走
            snowSystem.isFrozen = false; // 解冻
            snowSystem.isGenerating = false; // 不再生新
            snowSystem.clearOnExit = true; // 标记为清场模式
        }

        // --- 按钮事件绑定 ---

        ui.btnPlay.addEventListener('click', () => {
            if (state.status === 'idle') {
                startCountdown(() => {
                    startTimer();
                });
            } else if (state.status === 'running') {
                // 此时它是暂停按钮
                pauseTimer("user_click");
            }
        });

        ui.btnResume.addEventListener('click', () => {
            // 点击继续，5s倒计时后继续
            startCountdown(() => {
                startTimer();
            });
        });

        ui.btnRestart.addEventListener('click', () => {
            resetToIdle();
        });


        // --- 雪花系统 (Canvas) ---
        const ctx = ui.snowCanvas.getContext('2d');
        let width, height;

        function resize() {
            width = ui.snowCanvas.width = window.innerWidth;
            height = ui.snowCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        class Snowflake {
            constructor() {
                this.init();
            }

            init() {
                this.x = Math.random() * width;
                this.y = -10;
                this.size = Math.random() * 3 + 2;
                this.speedY = Math.random() * 1 + 0.5;
                this.speedX = Math.random() * 1 - 0.5;
                this.opacity = Math.random() * 0.5 + 0.3;
            }

            update() {
                this.y += this.speedY;
                this.x += this.speedX;

                // 如果是在清场模式，或者正常生成模式下出了屏幕
                if (this.y > height) {
                    if (snowSystem.isGenerating) {
                        this.y = -10;
                        this.x = Math.random() * width;
                    } else {
                        // 如果不生成新雪花，标记为dead
                        return false; 
                    }
                }
                return true;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.fill();
            }
        }

        const snowSystem = {
            flakes: [],
            isGenerating: false,
            isFrozen: false,
            clearOnExit: false,
            lastGenTime: 0
        };

        function animateSnow(timestamp) {
            ctx.clearRect(0, 0, width, height);

            // 生成新雪花
            if (snowSystem.isGenerating && !snowSystem.isFrozen) {
                if (timestamp - snowSystem.lastGenTime > 200) { // 控制生成频率
                    snowSystem.flakes.push(new Snowflake());
                    snowSystem.lastGenTime = timestamp;
                }
            }

            // 更新和绘制
            for (let i = snowSystem.flakes.length - 1; i >= 0; i--) {
                const flake = snowSystem.flakes[i];
                
                // 只有未冻结时才更新位置
                if (!snowSystem.isFrozen) {
                    const active = flake.update();
                    if (!active) {
                        snowSystem.flakes.splice(i, 1);
                        continue;
                    }
                }
                
                flake.draw();
            }

            requestAnimationFrame(animateSnow);
        }

        requestAnimationFrame(animateSnow);

    </script>
</body>
</html>