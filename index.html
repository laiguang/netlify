<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Focus Level</title>
    
    <!-- 引入圆润字体 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* 默认主题：春 Spring */
            --accent: #FFB7B2;
            --highlight: #FFDAC1;
            --text: #E27D60;
            --bg-color: #FFF5F5;
            --container-bg: #FFFFFF;
            --stripe-color: rgba(255, 183, 178, 0.2);
            --shadow: rgba(226, 125, 96, 0.2);
            
            --font-main: 'M PLUS Rounded 1c', sans-serif;
            --ease-bouncy: cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* 主题定义 - 通过 body 的 data-theme 切换 */
        body[data-theme="summer"] {
            --accent: #95D5B2;
            --highlight: #B7E4C7;
            --text: #40916C;
            --bg-color: #F0FFF4;
            --stripe-color: rgba(149, 213, 178, 0.2);
            --shadow: rgba(64, 145, 108, 0.2);
        }
        body[data-theme="autumn"] {
            --accent: #E29578;
            --highlight: #F6BD60;
            --text: #A65D48;
            --bg-color: #FFF8F0;
            --stripe-color: rgba(226, 149, 120, 0.2);
            --shadow: rgba(166, 93, 72, 0.2);
        }
        body[data-theme="winter"] {
            --accent: #98C1D9;
            --highlight: #E0FBFC;
            --text: #3D5A80;
            --bg-color: #F0F8FF;
            --stripe-color: rgba(152, 193, 217, 0.2);
            --shadow: rgba(61, 90, 128, 0.2);
        }
        body[data-theme="dark"] {
            --accent: #3D5A80;
            --highlight: #5F7C8A;
            --text: #E0FBFC;
            --bg-color: #293241;
            --container-bg: rgba(255, 255, 255, 0.05);
            --stripe-color: rgba(0, 0, 0, 0.2);
            --shadow: rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text);
            transition: all 0.5s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 背景条纹层 */
        .bg-stripes {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: linear-gradient(
                45deg, 
                var(--stripe-color) 25%, 
                transparent 25%, 
                transparent 50%, 
                var(--stripe-color) 50%, 
                var(--stripe-color) 75%, 
                transparent 75%, 
                transparent
            );
            background-size: 40px 40px;
            z-index: 0;
            opacity: 0.6;
        }

        /* 粒子 Canvas */
        #particle-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        /* 主容器 */
        .app-container {
            position: relative;
            z-index: 10;
            width: 90%;
            max-width: 400px;
            height: 85vh;
            max-height: 800px;
            background: var(--container-bg);
            border-radius: 40px;
            box-shadow: 0 10px 30px var(--shadow);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px 20px;
            transition: background 0.5s ease, box-shadow 0.5s ease;
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* 顶部数据区 */
        .top-data {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            opacity: 0.8;
            height: 30px;
        }

        /* 水平仪可视化区 */
        .level-visualizer {
            width: 240px;
            height: 240px;
            border: 8px solid var(--accent);
            border-radius: 50%;
            position: relative;
            margin-bottom: auto;
            transition: border-color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255,255,255,0.1);
            cursor: grab;
        }
        
        .level-visualizer:active {
            cursor: grabbing;
        }

        .level-visualizer.active {
            border-color: #95D5B2; /* 无论主题，水平时变绿 */
        }
        .level-visualizer.active .crosshair {
            background-color: transparent;
            border: 4px solid #95D5B2;
            width: 30px;
            height: 30px;
        }

        /* 误差圈 (虚线) */
        .error-zone {
            position: absolute;
            width: 40px; /* 对应 ±3度左右的视觉范围 */
            height: 40px;
            border: 2px dashed var(--accent);
            border-radius: 50%;
            opacity: 0.5;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .level-visualizer.active .error-zone {
            opacity: 0;
        }

        /* 准星 (小球) */
        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #FF6B6B; /* 默认红色表示未对准 */
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.3s, border 0.3s, width 0.3s, height 0.3s;
            /* 移动通过 transform */
            transform: translate(0, 0);
            will-change: transform;
            pointer-events: none;
        }

        /* 计时区 */
        .timer-display {
            font-size: 48px;
            font-weight: 700;
            color: var(--text);
            margin: 30px 0;
            font-variant-numeric: tabular-nums;
            letter-spacing: 2px;
        }

        /* 底部操作区 */
        .controls {
            display: flex;
            gap: 20px;
            height: 80px;
            align-items: center;
        }

        /* 按钮样式 Squircle */
        .btn {
            border: none;
            outline: none;
            background-color: var(--accent);
            color: var(--container-bg); /* 反色文字 */
            font-family: var(--font-main);
            font-size: 18px;
            font-weight: 700;
            padding: 15px 30px;
            border-radius: 20px; /* Squircle 模拟 */
            cursor: pointer;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
            transition: transform 0.1s var(--ease-bouncy), box-shadow 0.1s;
            min-width: 120px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        body[data-theme="dark"] .btn {
            color: #293241;
        }

        .btn:active {
            transform: scale(0.95) translateY(4px);
            box-shadow: 0 0 0 rgba(0,0,0,0.1);
        }

        .btn-secondary {
            background-color: var(--highlight);
            color: var(--text);
        }

        /* 弹窗提示 */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background-color: #FF6B6B;
            color: white;
            padding: 12px 24px;
            border-radius: 50px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: transform 0.4s var(--ease-bouncy);
            z-index: 100;
            white-space: nowrap;
        }
        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        .theme-hint {
            position: absolute;
            bottom: 10px;
            font-size: 12px;
            opacity: 0.5;
        }
    </style>
</head>
<body data-theme="spring">

    <!-- 背景层 -->
    <div class="bg-stripes"></div>
    <!-- 粒子层 -->
    <canvas id="particle-canvas"></canvas>

    <!-- 弹窗 -->
    <div id="toast" class="toast">请保持设备水平</div>

    <!-- 主界面 -->
    <div class="app-container">
        <!-- 顶部数据 -->
        <div class="top-data" id="angle-display">0°</div>

        <!-- 水平仪 -->
        <div class="level-visualizer" id="level-container">
            <div class="error-zone"></div>
            <div class="crosshair" id="crosshair"></div>
        </div>

        <!-- 计时器 -->
        <div class="timer-display" id="timer">00 : 00 : 00</div>

        <!-- 控制区 -->
        <div class="controls" id="controls-area">
            <button class="btn" id="main-btn">播放</button>
        </div>

        <div class="theme-hint">按空格键切换主题</div>
    </div>

    <script>
        /**
         * Focus Level - Single File Solution
         * Logic:
         * 1. Theme Management
         * 2. Particle System (Canvas)
         * 3. Gyroscope/Drag Input Logic
         * 4. Timer State Machine
         */

        // --- 1. 全局配置与状态 ---
        const config = {
            allowedError: 3, // degrees
            maxTiltVisual: 15, // degrees for visual clamping
            radius: 120, // visualizer radius in px
        };

        const state = {
            status: 'IDLE', // IDLE, COUNTDOWN, RUNNING, PAUSED
            startTime: 0,
            elapsedTime: 0, // ms
            currentTilt: { x: 0, y: 0, mag: 0 },
            isLevel: true,
            themeIndex: 0,
            themes: ['spring', 'summer', 'autumn', 'winter', 'dark'],
            wakeLock: null
        };

        const dom = {
            body: document.body,
            timer: document.getElementById('timer'),
            angle: document.getElementById('angle-display'),
            crosshair: document.getElementById('crosshair'),
            levelContainer: document.getElementById('level-container'),
            controls: document.getElementById('controls-area'),
            mainBtn: document.getElementById('main-btn'),
            toast: document.getElementById('toast'),
            canvas: document.getElementById('particle-canvas')
        };

        // --- 2. 主题管理 (Theme) ---
        function toggleTheme() {
            state.themeIndex = (state.themeIndex + 1) % state.themes.length;
            const newTheme = state.themes[state.themeIndex];
            dom.body.setAttribute('data-theme', newTheme);
            resetParticles(newTheme);
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') toggleTheme();
        });

        // --- 3. 传感器与物理逻辑 (Physics) ---
        
        // 桌面端鼠标模拟
        let isDragging = false;
        const containerRect = dom.levelContainer.getBoundingClientRect();
        const center = { x: containerRect.left + containerRect.width/2, y: containerRect.top + containerRect.height/2 };

        dom.levelContainer.addEventListener('mousedown', () => isDragging = true);
        window.addEventListener('mouseup', () => {
            if(isDragging) {
                isDragging = false;
                updateTilt(0, 0); // Reset on release for desktop convenience
            }
        });
        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            // 模拟计算：将鼠标偏移量映射为角度
            // 假设 100px 偏移 = 15度
            const dx = e.clientX - (dom.levelContainer.getBoundingClientRect().left + 120);
            const dy = e.clientY - (dom.levelContainer.getBoundingClientRect().top + 120);
            
            const factor = config.maxTiltVisual / 100; 
            updateTilt(dx * factor, dy * factor);
        });

        // 移动端陀螺仪
        function handleOrientation(event) {
            if (isDragging) return; // 优先开发测试用的拖拽

            // Beta: front-back (-180 to 180), Gamma: left-right (-90 to 90)
            // 我们只关心平放时的倾斜
            let x = event.gamma || 0; 
            let y = event.beta || 0;

            // 简单校准：手机平放时 beta/gamma 接近 0
            updateTilt(x, y);
        }

        function updateTilt(x, y) {
            // 限制最大角度以防止 UI 跑飞
            const magnitude = Math.sqrt(x*x + y*y);
            state.currentTilt = { x, y, mag: magnitude };
            
            // UI 更新
            dom.angle.textContent = `${Math.floor(magnitude)}°`;

            // 可视化准星移动
            // 将角度映射到像素距离 (1度 = 8px)
            const pxPerDeg = 8;
            let moveX = x * pxPerDeg;
            let moveY = y * pxPerDeg;

            // 限制在圆内
            const dist = Math.sqrt(moveX*moveX + moveY*moveY);
            if (dist > config.radius - 10) {
                const ratio = (config.radius - 10) / dist;
                moveX *= ratio;
                moveY *= ratio;
            }

            dom.crosshair.style.transform = `translate(${moveX}px, ${moveY}px)`;

            // 判定状态
            const wasLevel = state.isLevel;
            state.isLevel = magnitude <= config.allowedError;

            if (state.isLevel !== wasLevel) {
                if (state.isLevel) {
                    dom.levelContainer.classList.add('active');
                } else {
                    dom.levelContainer.classList.remove('active');
                    // 如果正在专注，触发中断
                    if (state.status === 'RUNNING') {
                        pauseTimer();
                        showToast("检测到设备倾斜，专注暂停");
                    }
                }
            }
        }

        // --- 4. 计时器逻辑 (Timer) ---
        let timerInterval;
        let countdownInterval;

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const h = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
            const s = (totalSeconds % 60).toString().padStart(2, '0');
            return `${h} : ${m} : ${s}`;
        }

        async function startCountdown() {
            // 请求权限 (iOS)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                    }
                } catch (e) { console.error(e); }
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }

            // 尝试 Wake Lock
            try {
                if ('wakeLock' in navigator) {
                    state.wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) { console.log('Wake Lock err', err); }

            state.status = 'COUNTDOWN';
            let count = 5;
            dom.mainBtn.textContent = count;
            dom.mainBtn.disabled = true;

            clearInterval(countdownInterval);
            countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    dom.mainBtn.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    checkStartCondition();
                }
            }, 1000);
        }

        function checkStartCondition() {
            if (state.isLevel) {
                startTimer();
            } else {
                state.status = 'IDLE';
                dom.mainBtn.textContent = '播放';
                dom.mainBtn.disabled = false;
                showToast("请保持设备水平");
            }
        }

        function startTimer() {
            state.status = 'RUNNING';
            // 按钮变为暂停
            dom.controls.innerHTML = `<button class="btn" onclick="manualPause()">暂停</button>`;
            
            // 记录起点
            const now = Date.now();
            // 如果是从暂停恢复，startTime 要减去已过时间
            state.startTime = now - state.elapsedTime;

            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                const current = Date.now();
                state.elapsedTime = current - state.startTime;
                dom.timer.textContent = formatTime(state.elapsedTime);
            }, 100); // 100ms update
        }

        function manualPause() {
            pauseTimer();
        }

        function pauseTimer() {
            if (state.status !== 'RUNNING') return;
            state.status = 'PAUSED';
            clearInterval(timerInterval);
            
            // 渲染暂停菜单
            dom.controls.innerHTML = `
                <button class="btn" onclick="resumeFlow()">继续</button>
                <button class="btn btn-secondary" onclick="resetFlow()">重新开始</button>
            `;
        }

        function resumeFlow() {
            // 点击继续，再次进入倒计时
            // 恢复初始按钮结构以便 startCountdown 操作
            dom.controls.innerHTML = `<button class="btn" id="main-btn">播放</button>`;
            dom.mainBtn = document.getElementById('main-btn'); // re-bind
            startCountdown();
        }

        function resetFlow() {
            state.status = 'IDLE';
            state.elapsedTime = 0;
            dom.timer.textContent = "00 : 00 : 00";
            dom.controls.innerHTML = `<button class="btn" id="main-btn">播放</button>`;
            dom.mainBtn = document.getElementById('main-btn'); // re-bind
            
            // 绑定初始点击事件
            dom.mainBtn.addEventListener('click', startCountdown);
            
            // 粒子特效处理：旧的飘走
            particles.forEach(p => p.stopping = true);
        }

        // 初始绑定
        dom.mainBtn.addEventListener('click', startCountdown);

        // 页面可见性处理 (切后台暂停)
        document.addEventListener("visibilitychange", () => {
            if (document.hidden && state.status === 'RUNNING') {
                pauseTimer();
            }
        });

        // 提示框逻辑
        let toastTimer;
        function showToast(msg) {
            dom.toast.textContent = msg;
            dom.toast.classList.add('show');
            clearTimeout(toastTimer);
            toastTimer = setTimeout(() => {
                dom.toast.classList.remove('show');
            }, 3000);
        }

        // --- 5. 粒子系统 (Canvas Particles) ---
        const ctx = dom.canvas.getContext('2d');
        let particles = [];
        let w, h;

        function resize() {
            w = dom.canvas.width = window.innerWidth;
            h = dom.canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        class Particle {
            constructor(theme) {
                this.x = Math.random() * w;
                this.y = -20; // Start above screen
                this.theme = theme;
                this.sizeBase = Math.random() * 5 + 3; // 3-8px
                // 大中小比例 1:2:1 (大概)
                const r = Math.random();
                if (r < 0.25) this.size = this.sizeBase * 1.5;
                else if (r > 0.75) this.size = this.sizeBase * 0.6;
                else this.size = this.sizeBase;

                this.speedY = Math.random() * 1 + 0.5;
                this.speedX = Math.random() * 1 - 0.5;
                this.oscillation = Math.random() * Math.PI * 2;
                this.oscillationSpeed = Math.random() * 0.05;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.stopping = false; // true if restart clicked (fall off)
            }

            update() {
                // 如果是暂停状态且不是正在清理旧粒子，则静止
                if (state.status === 'PAUSED' && !this.stopping) return;
                // 如果是倒计时状态且不是清理，静止
                if (state.status === 'COUNTDOWN' && !this.stopping) return;

                this.y += this.speedY;
                this.x += Math.sin(this.oscillation) * 0.5 + this.speedX;
                this.oscillation += this.oscillationSpeed;

                // 旋转效果 (visualized in draw)
                this.rotation = this.oscillation; 
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation || 0);
                ctx.globalAlpha = this.opacity;

                const color = getComputedStyle(document.body).getPropertyValue('--accent').trim();
                ctx.fillStyle = color;
                ctx.strokeStyle = color;

                switch(this.theme) {
                    case 'spring': // 花瓣 (Oval)
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.size, this.size/2, 0, 0, Math.PI*2);
                        ctx.fill();
                        break;
                    case 'summer': // 气泡 (Stroke Circle)
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI*2);
                        ctx.stroke();
                        // shine
                        ctx.beginPath();
                        ctx.arc(-this.size/3, -this.size/3, this.size/4, 0, Math.PI*2);
                        ctx.fillStyle = 'rgba(255,255,255,0.8)';
                        ctx.fill();
                        break;
                    case 'autumn': // 枫叶 (Diamond/Rotated Square)
                        ctx.rotate(Math.PI/4);
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        break;
                    case 'winter': // 雪花 (Circle blur)
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = 'white';
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size/1.5, 0, Math.PI*2);
                        ctx.fill();
                        break;
                    case 'dark': // 简化版
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI*2);
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        }

        function resetParticles(theme) {
            // 切换主题时，可以将旧粒子标记为 stopping，或者直接变色
            // 这里为了简单，直接变色（因为 update 逻辑会读取新的 CSS 变量）
            particles.forEach(p => p.theme = theme);
        }

        function animate() {
            ctx.clearRect(0, 0, w, h);

            // 生成新粒子
            if (state.status === 'RUNNING') {
                if (Math.random() < 0.03) { // 生成频率
                    particles.push(new Particle(state.themes[state.themeIndex]));
                }
            }

            // 更新与绘制
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();

                // 移除屏幕外的
                if (p.y > h + 20) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }
        animate();

    </script>
</body>
</html>
